import{_ as e,o as a,c as i,a as r}from"./app-CnbvU9a-.js";const d={},n=r('<h1 id="设计原则-solid" tabindex="-1"><a class="header-anchor" href="#设计原则-solid" aria-hidden="true">#</a> 设计原则(SOLID)</h1><p>设计原则是用来指导我们程序设计的指南，保证程序的健壮性和可维护性。它们是前辈们的总结，设计模式是对它们的实现</p><h2 id="单一职责原则-srp" tabindex="-1"><a class="header-anchor" href="#单一职责原则-srp" aria-hidden="true">#</a> 单一职责原则（SRP）</h2><p>单一职责原则（Single Responsibility Principle）一个类只负责一个功能领域，一个类应该只有一个引起它变化的原因。</p><h2 id="开闭原则-ocp" tabindex="-1"><a class="header-anchor" href="#开闭原则-ocp" aria-hidden="true">#</a> 开闭原则（OCP）</h2><p>开闭原则（Open Closed Principle）对扩展开放，对修改关闭。一个类去做扩展，但不能修改。</p><h2 id="里氏替换原则-lsp" tabindex="-1"><a class="header-anchor" href="#里氏替换原则-lsp" aria-hidden="true">#</a> 里氏替换原则（LSP）</h2><p>里氏替换原则（Liskov Substitution Principle）父类出现的地方，可以被子类替换，子类可以扩展父类的功能，但不能更改父类的功能。</p><h2 id="接口隔离原则-isp" tabindex="-1"><a class="header-anchor" href="#接口隔离原则-isp" aria-hidden="true">#</a> 接口隔离原则（ISP）</h2><p>接口隔离原则（Interface Segregation Principle）子类不应该继承基类中不使用的方法，应该调整基类或者拆分多个接口</p><h2 id="依赖倒转原则-dip" tabindex="-1"><a class="header-anchor" href="#依赖倒转原则-dip" aria-hidden="true">#</a> 依赖倒转原则（DIP）</h2><p>依赖倒转原则（Dependency Inversion Principal）抽象不应该依赖于细节，细节应该依赖于抽象，高层模块不应该直接依赖低层模块，应该都依赖于抽象，不能直接依赖具体类。</p><h2 id="迪米特法则-lod" tabindex="-1"><a class="header-anchor" href="#迪米特法则-lod" aria-hidden="true">#</a> 迪米特法则（LOD）</h2><p>迪米特法则（Law of Demeter）一个对象应该对其他对象有最少的了解</p><h2 id="合成复用原则-crp" tabindex="-1"><a class="header-anchor" href="#合成复用原则-crp" aria-hidden="true">#</a> 合成复用原则（CRP）</h2><p>合成复用原则（Composite Reuse Principle）尽量使用组合/聚合的方式，而不是使用继承。</p>',16),h=[n];function s(c,p){return a(),i("div",null,h)}const o=e(d,[["render",s],["__file","design-principle.html.vue"]]);export{o as default};
